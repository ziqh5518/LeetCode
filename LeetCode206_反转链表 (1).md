小记：之前学c++时，指针是个一直很让我头疼的问题，如果有一段时间做的题多了可能会记得比较牢固，后面不怎么做指针的题目后又忘得七七八八，现在用java写算法题，虽然java没有指针概念，都是引用类型，但也记录一下后面回顾起来会比较轻松

### 题目描述：
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![](https://cdn.nlark.com/yuque/0/2024/png/40606464/1729337669943-586600b4-1623-4d00-a783-7525faee77a0.png)![](https://cdn.nlark.com/yuque/0/2024/gif/40606464/1729337669403-d108b137-d1e2-480e-918e-a11ff922ce96.gif)编辑

### 题解思路
#### 虚拟头结点 VS 第一个有效结点	 				
+ **虚拟头结点**（又称哑结点，Dummy Head Node）:  是链表操作中常用的一种技巧，尤其在处理链表的插入、删除等操作时，能够简化代码，避免对链表头部操作时需要处理的特殊情况，在 Java 实现中，**虚拟头结点**是一个不存储有效数据的节点，通常作为链表的第一个节点。它的主要作用是为了简化链表操作的边界情况，尤其是当操作涉及链表的第一个有效节点时。	
+ **第一个有效结点**：顾名思义，即链表中第一个有数据的结点

#### **怎么判断head是虚拟头结点还是第一个有效结点**				
+ **查看链表的初始化代码：**链表的初始化方式可以帮助我们判断 `head` 是虚拟头结点还是第一个有效节点。这里有两种常见的链表初始化方式：		
    1. **使用虚拟头结点的初始化方式**：如果链表在初始化时使用了一个没有实际数据的虚拟头节点，它通常会这样写：	 		

```java
public class MyLinkedList {
    ListNode head;

    public MyLinkedList() {
        head = new ListNode(0); // 虚拟头结点，值可以是任意占位符
    }
}
// 在这种情况下，head 是一个虚拟头节点，链表的有效数据从 head.next 开始。
//通常在操作链表时会跳过 head，从 head.next 进行操作	
```

    2. ![](https://cdn.nlark.com/yuque/0/2024/gif/40606464/1729337669423-87ab9389-fd03-47ba-b6c8-4d1f9abff7a1.gif)**没有使用虚拟头结点的初始化方式**:如果链表不使用虚拟头节点，`head` 就是第一个有效节点，链表初始化可能这样写：

```java
// 有虚拟头结点
public void addAtHead(int val) {
    ListNode newNode = new ListNode(val);
    newNode.next = head.next;
    head.next = newNode; // 插入到虚拟头结点之后
}		
```



#### 代码逻辑图解
![](https://cdn.nlark.com/yuque/0/2024/png/40606464/1729338106341-dcc3aaac-c714-4644-a35c-52202d3326fa.png)![](https://cdn.nlark.com/yuque/0/2024/png/40606464/1729338220291-bfada089-5d46-4c71-88a5-fc25b8703975.png)![](https://cdn.nlark.com/yuque/0/2024/png/40606464/1729338287198-fb4b0063-7e40-42fe-870c-43216703529b.png)![](https://cdn.nlark.com/yuque/0/2024/png/40606464/1729338423198-0b1ffa44-384e-4f3b-9c0e-995e5162fae6.png)![](https://cdn.nlark.com/yuque/0/2024/png/40606464/1729338476644-1142ef28-81cd-4484-a955-75d35d407615.png)

